# Java 8 in Action 1장 summary

> 자바 **탄생 이래로 가장 큰 변화**는 8버전에서 일어났다. 그동안 자바는 애플리케이션 개발 측면에서 안정성이 뛰어나고 수많은 라이브러리, 객체지향의 장점을 내세우면서 프로그래밍 세계의 대세로 오랫동안 자리잡고 있었지만, 빅데이터가 등장하고 **concurrent하게 병렬 프로세싱이 가능한 코드를 짜는 데에는 한계**가 있었다. 스레드를 사용하면 여러 문제가 발생하고 불편하기 때문에 새로 탄생하는 함수형 프로그래밍 언어들이 대세로 뜨고 있는 추세였는데, 자바 8 버전에서 그동안 자바에서 볼 수 없었던 새로운 것들이 생겨났고, 그로 인해 **병렬 처리가 쉬워지고 함수형 프로그래밍이 가능**해졌다. `stream`과 `lamda`가 그 주인공이다. 이번 스터디에서는 자바 8에 대해서 자세히 알아보도록 할 것이다.

#### 이 책의 핵심과 흐름은 다음과 같다 (목차는 아님)

1. 프로그래밍 언어 생태계에서 자바의 위치
2. 스트림 처리
3. 동작 파라미터화로 메서드에 코드 전달하기
4. 병렬성과 공유 가변 데이터
5. 자바가 진화해야 하는 이유

*이 내용들을 한 줄로 요약하면 '언어는 하드웨어나 프로그래머 기대의 변화에 부응할 수 있도록 변화해야 한다' 이다.*

#### 자바 8에 추가된 새로운 개념

* **자바 함수**

  * 자바 8에서는 함수를 새로운 값의 형식으로 추가했다. 멀티코어에서 병렬 프로그래밍을 활용할 수 있는 스트림과 연계될 수 있도록 함수를 만들었다. 즉, 함수 자체가 값이 되어버린 것이다.
  * 자바 프로그램에서 조작할 수 있는 값은 `int`, `double`, `String` 등의 기본값과 객체 레퍼런스가 있다.

  > **그런데 왜 함수가 필요할까?**

  프로그래밍 언어의 핵심은 값을 바꾸는 것. 그리고 이 값을 전통적으로는 ***일급시민*** 이라고 부른다. 자바 프로그래밍 언어의 다양한 구조체(메서드, 클래스 등)가 값의 구조를 자유롭게 전달할 수는 없다. 이렇게 전달할 수 없는 구조체는 ***이급시민*** 이라고 한다. 즉 메서드와 클래스는 그 자체로 값이 될 수 없다. 하지만 런타임에 메서드를 전달할 수 있다면, 프로그래밍에 유용하게 활용할 수 있다. 그래서 자바 8 설계자들은 ***이급시민*** 을 ***일급시민*** 으로 바꿀 수 있는 기능을 추가한 것이다.

  1. **메서드와 람다를 일급 시민으로**

     * **메서드 레퍼런스** 

       ````java
       // 기존 자바 코드 (디렉터리에서 모든 숨겨진 파일을 필터링 한다고 가정한 코드)
       // FileFilter 객체로 isHidden 메서드를 감싼 다음에 File.listFiles 메서드로 전달해야함
       File[] hiddenFiles = new File(".").listFiles(new FileFilter(){
           public boolean accept(File file){
               return file.isHidden();
           }
       }) 
       
       ------------------------------------------------------------------------- 
       // 자바 8 메서드 레퍼런스 적용
           
       File[] hiddenFiles = new File(".").listFiles(File::isHidden);
       ````

       * `::` 은 자바 8에서 생긴 *메서드 레퍼런스* 라는 것이다. 이것의 의미는 **이 메서드를 값으로 사용하라** 이다.
       * 기존에 비해 문제 자체를 더 직접적으로 전달할 수 있다. 기존에 **객체 레퍼런스**(new로 객체 레퍼런스를 생성)를 이용해서 객체를 이리저리 주고받았던 것처럼 자바 8에서는 `File::isHidden` 을 이용해서 **메서드 레퍼런스** 를 만들어 전달할 수 있게 되었다.

     **람다 : 익명 함수**

     > 자바 8에서는 named 메서드를 일급시민으로 취급할 뿐 아니라 **람다(익명 함수)** 를 포함하여 **함수도 값** - 함수와 메서드는 다름 - 으로 취급할 수 있다

     * `(int x) -> x + 1` 의 의미는 'x라는 인수로 호출하면 x + 1을 반환' 이다. 즉, 동작을 수행하여 값이 되도록 코드를 짤 수가 있다. 
     * 직접 메서드를 정의할 수도 있지만, 이용할 수 있는 편리한 클래스나 메서드가 없을 때 새로운 람다 문법을 이용하면 더 간결하게 코드를 구현할 수 있다.
     * 람다 문법 형식으로 구현된 프로그램을 함수형 프로그래밍, 즉 ''*함수를 일급시민으로 넘겨주는 프로그램을 구현한다''* 라고 한다.

  2. **코드 넘겨주기: 예제**

     * 이것은 후에 자세히 나올 것이므로 생략한다.

       *TIP : 인수로 값을 받아 `true`, `false` 를 반환하는 함수를 Predicate 라고 한다.*

  3. **메서드 전달에서 람다로**

     * 메서드를 값으로 전달하는 것은 분명 유용한 기능이다. 하지만 한두 번만 사용할 메서드를 매번 정의하는 것은 귀찮다. 자바 8에서는 람다라는 새로운 개념을 통해 해결할 수 있다.

       ```java
       fileterApples(inventory, (Apple a) -> "green".equals(a.getColor()));
       fileterApples(inventory, (Apple a) -> a.getWeight() > 150);
       fileterApples(inventory, (Apple a) -> a.getWeight() < 80 || 			        "brown".equals(a.getColor());
       ```

       위 코드는 우리가 넘겨주려는 코드를 애써 찾을 필요가 없을 정도로 더 짧고 간결하다. 하지만 람다가 몇 줄 이상으로 길어진다면, 익명 람다보다는 named 메서드를 정의하고 **메서드 레퍼런스** 를 활용하는 것이 바람직하다. 코드의 명확성이 우선시 되어야한다. 

       **멀티코어 CPU**가 아니었다면 원래 자바 8 설계자들의 계획은 여기까지였을 것이다. 그리고 아마 자바는 filter 그리고 다음과 같은 몇몇 일반적인 라이브러리 메서드를 추가하는 방향으로 발전했을 수도 있다.

       ```java
       static <T> Collection<T> filter(Collection<T> c, Predicate<T> p);
       filter(inventory, (Apple a) - > a.getWeight() > 150);
       
       // 이렇게 아마 발전해 나갔을 것이다. 이렇게 구현하면. filterApples 메소드를 정의할 필요가 없다.
       
       filterApples(inventory, (Apple a) -> a.getWeight() > 150);
       ```

       > 하지만 병렬성이라는 중요성 때문에 자바 8에서는 `filter` 와 비슷한 동작을 수행하는 연산집합을 포함하는 새로운 **스트림 API**를 제공한다. 또한 Collection과 Stream간에 변환할 수 있는 메서드(map, reduce 등)들도 제공한다. 

#### Stream (스트림)

> 거의 모든 자바 애플리케이션은 컬렉션을 **만들고 활용**한다. 하지만 컬렉션으로 모든 문제가 해결되는 것은 아니다. 예를 들어서 리스트에서 고가의 거래만 필터링한 다음에 통화로 결과를 그룹화해야 한다고 가정하자. 다음 코드처럼 **많은 기본 코드를 구현해야한다.**

```java
Map<Currency, List<Transaction>> transactionsByCurrencies = new HashMap<>();

for(Transaction transaction : transactions) { 
	if(transaction.getPrice() > 1000) {
        Currency currency = transaction.getCurrency();
        List<Transaction> transactionsForCurrency = transactionByCurrencies.get(currency);
        if(transactionsForCurrency == null) {
            transactionsForCurrency = new ArrayList<>();
            transactionsByCurrencies.put(currency, transactionsForCurrency);
        }
        transactionsForCurrency.add(transaction);
	}
}


// 위 코드를 Java 8 Stream 사용해서 구현하기
import static java.util.stream.Collectors.toList;
Map<Currency, List<Transaction>> transactionsByCurrencies = transactions.stream()
    									.filter((Transaction t) -> t.getPrice() > 1000)
    									.collect(groupingBy(Transaction::getCurrency));
```

* 기존 코드는 중첩된 제어 흐름 문장이 많아서 코드를 한 번에 이해하기도 어렵다. 하지만 스트림 API를 이용하면 간결하고 가독성이 뛰어나게 구현할 수 있다. 스트림 API에 대한 지식이 없으면 위 예제 코드가 마술처럼 보일수도 있다. 하지만 익숙해지면 차이가 확실히 눈에 보일 것이다. 
* 스트림 API는 컬렉션 API와는 상당히 다르다. 컬렉션에서는 반복 과정을 for-each를 돌면서 작업했다. 이런 방식의 반복을 **외부 반복** 이라고 한다. 반면 스트림 API를 이용하면 LOOP를 신경 쓸 필요가 없다. 스트림 API에서는 라이브러리 내부에서 모든 데이터가 처리된다. 이와 같은 반복을 **내부 반복**이라고 한다.
* 컬렉션을 이용하면 다른 문제도 발생할 수 있다. 많은 요소를 가진 목록을 반복한다면 오랜 시간이 걸릴 수 있다는 것이다. 거대한 리스트는 어떻게 처리할까? 단일 CPU로는 거대한 데이터를 처리하기 힘들 것이다. 8개의 코어를 가진 컴퓨터라면 8개의 코어를 모두 사용하는 것이 8배 빨리 작업할 수 있게 하는 방법이다.

1. **멀티스레딩은 어렵다**

   * 이전 자바 버전에서 제공하는 스레드 API로 **멀테스레딩** 코드를 구현해서 병렬성을 이용하는 것은 쉽지 않다. 스레드를 잘 제어하지 못하면 원치 않는 방식으로 데이터가 바뀔 수 있다. 한마디로 다루기가 엄청 어렵다. 

   * 자바 8은 스트림 API로 '*컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제*' 와 *멀티코어 활용 어려움* 이라는 두 가지 문제를 모두 해결했다. 기존의 컬렉션에서는 데이터를 처리할 때 반복되는 패턴이 너무 많았다. 이러한 반복되는 패턴을 제공하면 좋을 것이라는 아이디어가 변화의 동기가 되었다. 필터링, 데이터 추출, 데이터 그룹화 등의 기능이 있다

   * 각각의 CPU는 자신이 맡은 부분을 처리한다. (공장 라인을 생각하면 이해하기 쉽다. 맡은 부분만 수행하되, 동시에 돌아가는 것이다). 새로운 스트림 API가 기존의 컬렉션 API와 비슷해 보일 수 있다. 하지만 **컬렉션은 어떻게 데이터를 저장하고 접근할지에 중점을 두었고, 스트림은 데이터에 어떤 계산을 할 것인지 묘사하는 것에 중점을 뒀다.**

   * 컬렉션을 필터링할 수 있는 **가장 빠른 방법**은 *컬렉션을 스트림으로 바꾸고, 병렬로 처리한 다음에, 리스트로 다시 복원하는 것*이다. 스트림과 람다 표현식을 이용하면 *'병렬성을 공짜로'* 얻을 수 있고 병렬로 필터링을 할 수 있다.

     > 자바의 변화 과정에서 자바 8 개발자들이 겪는 어려움 중 하나는 기존 인터페이스의 변경이다. 얘를 들어 `Collections.sort` 는 사실 List 인터페이스에 포함되지만, 실제로 List에 포함된 적은 없다. 이것을 고치려면 인터페이스를 구현하는 모든 클래스를 업데이트 해야하므로 불가능에 가까웠다. 하지만 자바 8에서 **디폴트 메서드**를 통해 이 문제를 해결할 수 있게 되었다.



#### 디폴트 메서드

> 자바 8 에서는 라이브러리 설계자가 더 쉽게 변화할 수 있는 인터페이스를 만들 수 있도록 디폴트 메서드를 추가했다. 앞으로 인터페이스에서 디폴트 메서드를 많이 만나게 될 것이다. 하지만 프로그래머가 직접 디폴트 메서드를 구현하는 상황은 흔치 않다. 디폴트 메서드는 특정 프로그램을 구현하는 데 도움을 주는 기능이 아니라 미래에 프로그램이 쉽게 변화할 수 있는 환경을 제공하는 기능이다.

```java
List<Apple> heavyApples1 = inventory.stream().filter((Apple a) -> a.getWeight() > 150)
											.collect(toList());
											
List<Apple> heavyApples2 = inventory.parallelStream().filter((Apple a) -> a.getWeight() > 150).collect(toList());
```

자바 8 이전에는 위의 stream, parallelStream 메서드를 지원하지 않았다. List 인터페이스나 Collection 인터페이스에 이러한 구현들이 없기 때문이다. 따라서 이 소스는 자바 8 이 아니면 컴파일이 불가능하다. 가장 간단한 해결책은 직접 Collection 인터페이스에 Stream을 구현하고, ArrayList에 메서드를 구현하는 방법이다. 

​							*하지만 이 방법은 사용자에게 너무 큰 고통을 안겨준다* 

왜냐하면 이미 Collection API의 인터페이스를 구현하는 많은 Collection Framework가 존재한다. 인터페이스에 새로운 메서드를 추가한다면 인터페이스를 구현하는 모든 클래스는 새로 추가된 메서드를 구현해야 한다. 그래서 우리는 딜레마에 빠진다.

​				*어떻게 기존의 구현을 고치지 않고도 이미 공개된 인터페이스를 변경할 수 있을까?*

- 자바 8은 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스가 포함할 수 있는 기능을 제공한다. 이것이 바로 **디폴트 메서드**이다. 
- 디폴트 메서드 바디는 인터페이스의 일부로 포함된다.

> 예를 들어 자바 8에서는 List에 직접 sort 메서드를 호출할 수 있다. 이는 자바 8의 List 인터페이스에 다음과 같은 디폴트 메서드 정의가 추가되었기 때문이다.

```java
default void sort(Comparator<? super E> c) {
    Collections.sort(this, c);
}
```

따라서 자바 8 이전에는 List를 구현하는 모든 클래스가 sort를 구현해야 했지만 자바 8부터는 디폴트 sort를 구현하지 않아도 된다.



#### 함수형 프로그램에서 가져온 다른 유용한 아이디어

일반적인 함수형 언어(SML, 오캐멀, 하스켈)도 프로그램을 돕는 여러 장치를 제공한다. 일례로 명시적으로 데이터 형식을 설명하도록 유도함으로써 null을 회피하는 기법이 있다. 컴퓨터 거장인 토니 호아레는 2009년에 다음과 같은 말을 했다.

> "1965년에 NULL 레퍼런스를 발명했던 일을 회상하며 그 결정은 정말 뼈아픈 실수였다고 반성하고 있다... 단지 구현이 편리하단 이유로 NULL 레퍼런스를 만들어야겠다는 유혹을 뿌리치지 못했다."

* 자바 8에서는 NullPointer 예외를 피할 수 있도록 도와주는 `Optional<T>` 클래스를 제공한다. 값을 갖거나 갖지 않을 수 있는 컨테이너 객체다. 어떤 변수에 값이 없을 때 어떻게 처리할지 명시할 수 있다.

---

### *요약*

* 언어 생태계의 모든 언어는 변화해서 살아남거나 그대로 머물면서 사라지게 되는 상황에 놓인다. 지금은 자바의 위치가 견고하지만 코볼 같은 언어의 선례를 떠올리면 자바가 영원히 지배적인 위치를 유지할 수 있는 것은 아닐 수 있다.
* 자바 8은 프로그램을 더 효과적이고 간결하게 구현할 수 있는 새로운 개념과 기능을 제공한다.
* 기존의 자바 프로그래밍 기법으로는 멀티코어 프로세서를 온전히 활용하기 어렵다.
* 함수는 일급시민이다. 메서드를 어떻게 함수형값으로 넘겨주는지, 람다를 어떻게 구현하는지 기억하자
* 자바 8의 스트림 개념 중 일부는 컬렉션에서 가져온 것이다. 스트림과 컬렉션을 적절하게 활용하면 스트림의 인수를 병렬로 처리할 수 있으며 더 가독성이 좋은 코드를 구현할 수 있다.
* 인터페이스에서 디폴트 메서드를 이용하면 메서드 바디를 제공할 수 있으므로 인터페이스를 구현하는 다른 클래스에서 해당 메서드를 구현하지 않아도 된다.
* 함수형 프로그래밍에서 null 처리 방법과 패턴 매칭 활용 등 흥미로운 기법을 발견할 수 있었다.
